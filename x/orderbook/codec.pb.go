// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: x/orderbook/codec.proto

package orderbook

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_iov_one_weave "github.com/iov-one/weave"
	weave "github.com/iov-one/weave"
	coin "github.com/iov-one/weave/coin"
	io "io"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// OrderState defines if the proposal is active
type OrderState int32

const (
	OrderState_Invalid OrderState = 0
	// Open orders can create trades
	OrderState_Open OrderState = 1
	// Done orders have been fulfilled and are empty
	OrderState_Done OrderState = 2
	// Cancelled orders were closed at the makers request before they were fulfilled
	OrderState_Cancel OrderState = 3
)

var OrderState_name = map[int32]string{
	0: "ORDER_STATE_INVALID",
	1: "ORDER_STATE_OPEN",
	2: "ORDER_STATE_DONE",
	3: "ORDER_STATE_CANCEL",
}

var OrderState_value = map[string]int32{
	"ORDER_STATE_INVALID": 0,
	"ORDER_STATE_OPEN":    1,
	"ORDER_STATE_DONE":    2,
	"ORDER_STATE_CANCEL":  3,
}

func (x OrderState) String() string {
	return proto.EnumName(OrderState_name, int32(x))
}

func (OrderState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_492308ae36fa08c1, []int{0}
}

// Side determines which side of the orderbook we are on (ask or bid)
// This defines the appropriate ticker (ask_ticker or bid_ticker)
type Side int32

const (
	Side_Invalid Side = 0
	Side_Ask     Side = 1
	Side_Bid     Side = 2
)

var Side_name = map[int32]string{
	0: "SIDE_INVALID",
	1: "SIDE_ASK",
	2: "SIDE_BID",
}

var Side_value = map[string]int32{
	"SIDE_INVALID": 0,
	"SIDE_ASK":     1,
	"SIDE_BID":     2,
}

func (x Side) String() string {
	return proto.EnumName(Side_name, int32(x))
}

func (Side) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_492308ae36fa08c1, []int{1}
}

// Amount is like a coin.Coin but without a ticker.
// We use it where a ticker is impossible (like quantity)
// For offers where ticker is implied, we still use coin.Coin
// as we inherit much math from there.
//
// TODO: work out how to multiply Amount * Coin
type Amount struct {
	// Whole coins, -10^15 < integer < 10^15
	Whole int64 `protobuf:"varint,1,opt,name=whole,proto3" json:"whole,omitempty"`
	// Billionth of coins. 0 <= abs(fractional) < 10^9
	// If fractional != 0, must have same sign as integer
	Fractional int64 `protobuf:"varint,2,opt,name=fractional,proto3" json:"fractional,omitempty"`
}

func (m *Amount) Reset()         { *m = Amount{} }
func (m *Amount) String() string { return proto.CompactTextString(m) }
func (*Amount) ProtoMessage()    {}
func (*Amount) Descriptor() ([]byte, []int) {
	return fileDescriptor_492308ae36fa08c1, []int{0}
}
func (m *Amount) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Amount) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Amount.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Amount) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Amount.Merge(m, src)
}
func (m *Amount) XXX_Size() int {
	return m.Size()
}
func (m *Amount) XXX_DiscardUnknown() {
	xxx_messageInfo_Amount.DiscardUnknown(m)
}

var xxx_messageInfo_Amount proto.InternalMessageInfo

func (m *Amount) GetWhole() int64 {
	if m != nil {
		return m.Whole
	}
	return 0
}

func (m *Amount) GetFractional() int64 {
	if m != nil {
		return m.Fractional
	}
	return 0
}

// Order is a request to make a trade.
// We create an order for every trade request, even if it settles immediately,
// in order to provide history and clean auditability of the market.
type Order struct {
	Metadata *weave.Metadata `protobuf:"bytes,1,opt,name=metadata,proto3" json:"metadata,omitempty"`
	ID       []byte          `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty"`
	// Address of trader that created order (ad gets paid from it)
	Trader      github_com_iov_one_weave.Address `protobuf:"bytes,3,opt,name=trader,proto3,casttype=github.com/iov-one/weave.Address" json:"trader,omitempty"`
	OrderBookID []byte                           `protobuf:"bytes,4,opt,name=order_book_id,json=orderBookId,proto3" json:"order_book_id,omitempty"`
	Side        Side                             `protobuf:"varint,5,opt,name=side,proto3,enum=orderbook.Side" json:"side,omitempty"`
	OrderState  OrderState                       `protobuf:"varint,6,opt,name=order_state,json=orderState,proto3,enum=orderbook.OrderState" json:"order_state,omitempty"`
	// The amount maker want to sell/buy
	OriginalOffer *coin.Coin `protobuf:"bytes,7,opt,name=original_offer,json=originalOffer,proto3" json:"original_offer,omitempty"`
	// Remaning offer. (This part enables partially filled orders)
	RemainingOffer *coin.Coin `protobuf:"bytes,8,opt,name=remaining_offer,json=remainingOffer,proto3" json:"remaining_offer,omitempty"`
	// Price for each unit (in tickers of the opposite currency from our side)
	Price *Amount `protobuf:"bytes,9,opt,name=price,proto3" json:"price,omitempty"`
	// Executed trades (referenced ids)
	TradeIds [][]byte `protobuf:"bytes,10,rep,name=trade_ids,json=tradeIds,proto3" json:"trade_ids,omitempty"`
	// created_at defines create time of an order
	CreatedAt github_com_iov_one_weave.UnixTime `protobuf:"varint,11,opt,name=created_at,json=createdAt,proto3,casttype=github.com/iov-one/weave.UnixTime" json:"created_at,omitempty"`
	// updated_at defines update time of an order
	UpdatedAt github_com_iov_one_weave.UnixTime `protobuf:"varint,12,opt,name=updated_at,json=updatedAt,proto3,casttype=github.com/iov-one/weave.UnixTime" json:"updated_at,omitempty"`
}

func (m *Order) Reset()         { *m = Order{} }
func (m *Order) String() string { return proto.CompactTextString(m) }
func (*Order) ProtoMessage()    {}
func (*Order) Descriptor() ([]byte, []int) {
	return fileDescriptor_492308ae36fa08c1, []int{1}
}
func (m *Order) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Order) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Order.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Order) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Order.Merge(m, src)
}
func (m *Order) XXX_Size() int {
	return m.Size()
}
func (m *Order) XXX_DiscardUnknown() {
	xxx_messageInfo_Order.DiscardUnknown(m)
}

var xxx_messageInfo_Order proto.InternalMessageInfo

func (m *Order) GetMetadata() *weave.Metadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *Order) GetID() []byte {
	if m != nil {
		return m.ID
	}
	return nil
}

func (m *Order) GetTrader() github_com_iov_one_weave.Address {
	if m != nil {
		return m.Trader
	}
	return nil
}

func (m *Order) GetOrderBookID() []byte {
	if m != nil {
		return m.OrderBookID
	}
	return nil
}

func (m *Order) GetSide() Side {
	if m != nil {
		return m.Side
	}
	return Side_Invalid
}

func (m *Order) GetOrderState() OrderState {
	if m != nil {
		return m.OrderState
	}
	return OrderState_Invalid
}

func (m *Order) GetOriginalOffer() *coin.Coin {
	if m != nil {
		return m.OriginalOffer
	}
	return nil
}

func (m *Order) GetRemainingOffer() *coin.Coin {
	if m != nil {
		return m.RemainingOffer
	}
	return nil
}

func (m *Order) GetPrice() *Amount {
	if m != nil {
		return m.Price
	}
	return nil
}

func (m *Order) GetTradeIds() [][]byte {
	if m != nil {
		return m.TradeIds
	}
	return nil
}

func (m *Order) GetCreatedAt() github_com_iov_one_weave.UnixTime {
	if m != nil {
		return m.CreatedAt
	}
	return 0
}

func (m *Order) GetUpdatedAt() github_com_iov_one_weave.UnixTime {
	if m != nil {
		return m.UpdatedAt
	}
	return 0
}

// Trade is a settled partial/full order
// We store these as independent entities to help with queries to map
// the prices over time. They are also referenced by the Orders, so we can
// see how much was fulfilled.
//
// Ask and Bid tickers are "inherited" from the orderbook
type Trade struct {
	Metadata    *weave.Metadata `protobuf:"bytes,1,opt,name=metadata,proto3" json:"metadata,omitempty"`
	ID          []byte          `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty"`
	OrderBookID []byte          `protobuf:"bytes,3,opt,name=order_book_id,json=orderBookId,proto3" json:"order_book_id,omitempty"`
	OrderID     []byte          `protobuf:"bytes,4,opt,name=order_id,json=orderId,proto3" json:"order_id,omitempty"`
	// Address of taker (this is an order that was instantly fulfilled)
	Taker github_com_iov_one_weave.Address `protobuf:"bytes,5,opt,name=taker,proto3,casttype=github.com/iov-one/weave.Address" json:"taker,omitempty"`
	// Address of maker (this is an order that was stored first before fulfillment)
	Maker github_com_iov_one_weave.Address `protobuf:"bytes,6,opt,name=maker,proto3,casttype=github.com/iov-one/weave.Address" json:"maker,omitempty"`
	// this is how much each side paid (they got the opposite one)
	MakerPaid *coin.Coin `protobuf:"bytes,7,opt,name=maker_paid,json=makerPaid,proto3" json:"maker_paid,omitempty"`
	TakerPaid *coin.Coin `protobuf:"bytes,8,opt,name=taker_paid,json=takerPaid,proto3" json:"taker_paid,omitempty"`
	// executed_at defines execution time of an order
	ExecutedAt github_com_iov_one_weave.UnixTime `protobuf:"varint,9,opt,name=executed_at,json=executedAt,proto3,casttype=github.com/iov-one/weave.UnixTime" json:"executed_at,omitempty"`
}

func (m *Trade) Reset()         { *m = Trade{} }
func (m *Trade) String() string { return proto.CompactTextString(m) }
func (*Trade) ProtoMessage()    {}
func (*Trade) Descriptor() ([]byte, []int) {
	return fileDescriptor_492308ae36fa08c1, []int{2}
}
func (m *Trade) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Trade) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Trade.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Trade) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Trade.Merge(m, src)
}
func (m *Trade) XXX_Size() int {
	return m.Size()
}
func (m *Trade) XXX_DiscardUnknown() {
	xxx_messageInfo_Trade.DiscardUnknown(m)
}

var xxx_messageInfo_Trade proto.InternalMessageInfo

func (m *Trade) GetMetadata() *weave.Metadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *Trade) GetID() []byte {
	if m != nil {
		return m.ID
	}
	return nil
}

func (m *Trade) GetOrderBookID() []byte {
	if m != nil {
		return m.OrderBookID
	}
	return nil
}

func (m *Trade) GetOrderID() []byte {
	if m != nil {
		return m.OrderID
	}
	return nil
}

func (m *Trade) GetTaker() github_com_iov_one_weave.Address {
	if m != nil {
		return m.Taker
	}
	return nil
}

func (m *Trade) GetMaker() github_com_iov_one_weave.Address {
	if m != nil {
		return m.Maker
	}
	return nil
}

func (m *Trade) GetMakerPaid() *coin.Coin {
	if m != nil {
		return m.MakerPaid
	}
	return nil
}

func (m *Trade) GetTakerPaid() *coin.Coin {
	if m != nil {
		return m.TakerPaid
	}
	return nil
}

func (m *Trade) GetExecutedAt() github_com_iov_one_weave.UnixTime {
	if m != nil {
		return m.ExecutedAt
	}
	return 0
}

// An Orderbook lives in a market and represents a ask/bid pair.
// We only allow one orderbook for each pair. To avoid confusion,
// we enforce ask_ticker < bid_ticker so their cannot be two orderbooks
// for the same trading pair.
//
// Orders and Trades must reference an orderbook and use those tickers as denominations
type OrderBook struct {
	Metadata  *weave.Metadata `protobuf:"bytes,1,opt,name=metadata,proto3" json:"metadata,omitempty"`
	ID        []byte          `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty"`
	MarketID  []byte          `protobuf:"bytes,3,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	AskTicker string          `protobuf:"bytes,4,opt,name=ask_ticker,json=askTicker,proto3" json:"ask_ticker,omitempty"`
	BidTicker string          `protobuf:"bytes,5,opt,name=bid_ticker,json=bidTicker,proto3" json:"bid_ticker,omitempty"`
	// repeated Order ask_orders = 5;
	TotalAskCount int64 `protobuf:"varint,6,opt,name=total_ask_count,json=totalAskCount,proto3" json:"total_ask_count,omitempty"`
	// repeated Order bid_orders = 7;
	TotalBidCount int64 `protobuf:"varint,7,opt,name=total_bid_count,json=totalBidCount,proto3" json:"total_bid_count,omitempty"`
}

func (m *OrderBook) Reset()         { *m = OrderBook{} }
func (m *OrderBook) String() string { return proto.CompactTextString(m) }
func (*OrderBook) ProtoMessage()    {}
func (*OrderBook) Descriptor() ([]byte, []int) {
	return fileDescriptor_492308ae36fa08c1, []int{3}
}
func (m *OrderBook) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OrderBook) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OrderBook.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OrderBook) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OrderBook.Merge(m, src)
}
func (m *OrderBook) XXX_Size() int {
	return m.Size()
}
func (m *OrderBook) XXX_DiscardUnknown() {
	xxx_messageInfo_OrderBook.DiscardUnknown(m)
}

var xxx_messageInfo_OrderBook proto.InternalMessageInfo

func (m *OrderBook) GetMetadata() *weave.Metadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *OrderBook) GetID() []byte {
	if m != nil {
		return m.ID
	}
	return nil
}

func (m *OrderBook) GetMarketID() []byte {
	if m != nil {
		return m.MarketID
	}
	return nil
}

func (m *OrderBook) GetAskTicker() string {
	if m != nil {
		return m.AskTicker
	}
	return ""
}

func (m *OrderBook) GetBidTicker() string {
	if m != nil {
		return m.BidTicker
	}
	return ""
}

func (m *OrderBook) GetTotalAskCount() int64 {
	if m != nil {
		return m.TotalAskCount
	}
	return 0
}

func (m *OrderBook) GetTotalBidCount() int64 {
	if m != nil {
		return m.TotalBidCount
	}
	return 0
}

// A market holds many Orderbooks and is just a grouping for now.
// Probably we only want one market on a chain, but we could add additional
// rules to each market and then allow multiple.
//
// Currently Markets can only be created in the genesis file
type Market struct {
	Metadata *weave.Metadata `protobuf:"bytes,1,opt,name=metadata,proto3" json:"metadata,omitempty"`
	ID       []byte          `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty"`
	// Owner is allowed to create new orderbooks in this Market
	Owner github_com_iov_one_weave.Address `protobuf:"bytes,3,opt,name=owner,proto3,casttype=github.com/iov-one/weave.Address" json:"owner,omitempty"`
	// Market name
	Name string `protobuf:"bytes,4,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *Market) Reset()         { *m = Market{} }
func (m *Market) String() string { return proto.CompactTextString(m) }
func (*Market) ProtoMessage()    {}
func (*Market) Descriptor() ([]byte, []int) {
	return fileDescriptor_492308ae36fa08c1, []int{4}
}
func (m *Market) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Market) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Market.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Market) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Market.Merge(m, src)
}
func (m *Market) XXX_Size() int {
	return m.Size()
}
func (m *Market) XXX_DiscardUnknown() {
	xxx_messageInfo_Market.DiscardUnknown(m)
}

var xxx_messageInfo_Market proto.InternalMessageInfo

func (m *Market) GetMetadata() *weave.Metadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *Market) GetID() []byte {
	if m != nil {
		return m.ID
	}
	return nil
}

func (m *Market) GetOwner() github_com_iov_one_weave.Address {
	if m != nil {
		return m.Owner
	}
	return nil
}

func (m *Market) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// CreateOrderMsg will offer to sell some currency on an orderbook
// at a given price.
type CreateOrderMsg struct {
	Metadata *weave.Metadata `protobuf:"bytes,1,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// Trader is the Address that will pay the offer, and get the matches.
	// Defaults to x.MainSigner() if left blank
	Trader github_com_iov_one_weave.Address `protobuf:"bytes,2,opt,name=trader,proto3,casttype=github.com/iov-one/weave.Address" json:"trader,omitempty"`
	// OrderBookID must support Offer.Ticker as one of the two sides,
	// Which side this order will be, is automatically inferred
	OrderBookID []byte `protobuf:"bytes,3,opt,name=order_book_id,json=orderBookId,proto3" json:"order_book_id,omitempty"`
	// Offer is how much will be paid
	Offer *coin.Coin `protobuf:"bytes,4,opt,name=offer,proto3" json:"offer,omitempty"`
	// Price is how much is requested for each unit of the offer token
	Price *Amount `protobuf:"bytes,5,opt,name=price,proto3" json:"price,omitempty"`
}

func (m *CreateOrderMsg) Reset()         { *m = CreateOrderMsg{} }
func (m *CreateOrderMsg) String() string { return proto.CompactTextString(m) }
func (*CreateOrderMsg) ProtoMessage()    {}
func (*CreateOrderMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor_492308ae36fa08c1, []int{5}
}
func (m *CreateOrderMsg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateOrderMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateOrderMsg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateOrderMsg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateOrderMsg.Merge(m, src)
}
func (m *CreateOrderMsg) XXX_Size() int {
	return m.Size()
}
func (m *CreateOrderMsg) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateOrderMsg.DiscardUnknown(m)
}

var xxx_messageInfo_CreateOrderMsg proto.InternalMessageInfo

func (m *CreateOrderMsg) GetMetadata() *weave.Metadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *CreateOrderMsg) GetTrader() github_com_iov_one_weave.Address {
	if m != nil {
		return m.Trader
	}
	return nil
}

func (m *CreateOrderMsg) GetOrderBookID() []byte {
	if m != nil {
		return m.OrderBookID
	}
	return nil
}

func (m *CreateOrderMsg) GetOffer() *coin.Coin {
	if m != nil {
		return m.Offer
	}
	return nil
}

func (m *CreateOrderMsg) GetPrice() *Amount {
	if m != nil {
		return m.Price
	}
	return nil
}

// CancelOrderMsg will remove a standing order.
// It must be authorized by the trader who created the order.
// All remaining funds return to that address.
type CancelOrderMsg struct {
	Metadata *weave.Metadata `protobuf:"bytes,1,opt,name=metadata,proto3" json:"metadata,omitempty"`
	OrderID  []byte          `protobuf:"bytes,2,opt,name=order_id,json=orderId,proto3" json:"order_id,omitempty"`
}

func (m *CancelOrderMsg) Reset()         { *m = CancelOrderMsg{} }
func (m *CancelOrderMsg) String() string { return proto.CompactTextString(m) }
func (*CancelOrderMsg) ProtoMessage()    {}
func (*CancelOrderMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor_492308ae36fa08c1, []int{6}
}
func (m *CancelOrderMsg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CancelOrderMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CancelOrderMsg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CancelOrderMsg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CancelOrderMsg.Merge(m, src)
}
func (m *CancelOrderMsg) XXX_Size() int {
	return m.Size()
}
func (m *CancelOrderMsg) XXX_DiscardUnknown() {
	xxx_messageInfo_CancelOrderMsg.DiscardUnknown(m)
}

var xxx_messageInfo_CancelOrderMsg proto.InternalMessageInfo

func (m *CancelOrderMsg) GetMetadata() *weave.Metadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *CancelOrderMsg) GetOrderID() []byte {
	if m != nil {
		return m.OrderID
	}
	return nil
}

// CreateOrderBookMsg creates a new orderbook in an existing market.
// It must be executed by the owner of the market.
type CreateOrderBookMsg struct {
	Metadata  *weave.Metadata `protobuf:"bytes,1,opt,name=metadata,proto3" json:"metadata,omitempty"`
	MarketID  []byte          `protobuf:"bytes,2,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	AskTicker string          `protobuf:"bytes,3,opt,name=ask_ticker,json=askTicker,proto3" json:"ask_ticker,omitempty"`
	BidTicker string          `protobuf:"bytes,4,opt,name=bid_ticker,json=bidTicker,proto3" json:"bid_ticker,omitempty"`
}

func (m *CreateOrderBookMsg) Reset()         { *m = CreateOrderBookMsg{} }
func (m *CreateOrderBookMsg) String() string { return proto.CompactTextString(m) }
func (*CreateOrderBookMsg) ProtoMessage()    {}
func (*CreateOrderBookMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor_492308ae36fa08c1, []int{7}
}
func (m *CreateOrderBookMsg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateOrderBookMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateOrderBookMsg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateOrderBookMsg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateOrderBookMsg.Merge(m, src)
}
func (m *CreateOrderBookMsg) XXX_Size() int {
	return m.Size()
}
func (m *CreateOrderBookMsg) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateOrderBookMsg.DiscardUnknown(m)
}

var xxx_messageInfo_CreateOrderBookMsg proto.InternalMessageInfo

func (m *CreateOrderBookMsg) GetMetadata() *weave.Metadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *CreateOrderBookMsg) GetMarketID() []byte {
	if m != nil {
		return m.MarketID
	}
	return nil
}

func (m *CreateOrderBookMsg) GetAskTicker() string {
	if m != nil {
		return m.AskTicker
	}
	return ""
}

func (m *CreateOrderBookMsg) GetBidTicker() string {
	if m != nil {
		return m.BidTicker
	}
	return ""
}

func init() {
	proto.RegisterEnum("orderbook.OrderState", OrderState_name, OrderState_value)
	proto.RegisterEnum("orderbook.Side", Side_name, Side_value)
	proto.RegisterType((*Amount)(nil), "orderbook.Amount")
	proto.RegisterType((*Order)(nil), "orderbook.Order")
	proto.RegisterType((*Trade)(nil), "orderbook.Trade")
	proto.RegisterType((*OrderBook)(nil), "orderbook.OrderBook")
	proto.RegisterType((*Market)(nil), "orderbook.Market")
	proto.RegisterType((*CreateOrderMsg)(nil), "orderbook.CreateOrderMsg")
	proto.RegisterType((*CancelOrderMsg)(nil), "orderbook.CancelOrderMsg")
	proto.RegisterType((*CreateOrderBookMsg)(nil), "orderbook.CreateOrderBookMsg")
}

func init() { proto.RegisterFile("x/orderbook/codec.proto", fileDescriptor_492308ae36fa08c1) }

var fileDescriptor_492308ae36fa08c1 = []byte{
	// 944 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x56, 0x4f, 0x6f, 0xe2, 0x46,
	0x14, 0x8f, 0x0d, 0x06, 0xfc, 0x20, 0x40, 0xa7, 0xbb, 0xad, 0x45, 0xb5, 0x40, 0x69, 0xba, 0x4d,
	0xb6, 0x2a, 0xa8, 0x1b, 0xa9, 0x87, 0x55, 0x55, 0xc9, 0x60, 0x2a, 0x59, 0xdd, 0x84, 0x95, 0xa1,
	0xbd, 0x5a, 0x83, 0x67, 0xc2, 0x8e, 0x00, 0x0f, 0xb2, 0x27, 0x7f, 0xbe, 0x42, 0x73, 0xea, 0xa9,
	0x37, 0xbe, 0x40, 0xbf, 0x44, 0xaf, 0x3d, 0xee, 0xa9, 0xea, 0x09, 0x55, 0xe4, 0x5b, 0x6c, 0x2f,
	0x95, 0xc7, 0xc4, 0xb0, 0x9b, 0x26, 0x0a, 0x55, 0x6e, 0xe3, 0xf7, 0xfb, 0xfd, 0x1e, 0xcf, 0xef,
	0xf7, 0xe6, 0x19, 0xf8, 0xf8, 0xa2, 0xc5, 0x03, 0x42, 0x83, 0x21, 0xe7, 0xe3, 0x96, 0xc7, 0x09,
	0xf5, 0x9a, 0xb3, 0x80, 0x0b, 0x8e, 0xf4, 0x24, 0x5c, 0xd9, 0x1b, 0x31, 0xf1, 0xfa, 0x74, 0xd8,
	0xf4, 0xf8, 0xb4, 0xc5, 0xf8, 0xd9, 0x57, 0xdc, 0xa7, 0xad, 0x73, 0x8a, 0xcf, 0xe8, 0xa6, 0xa0,
	0x72, 0x70, 0x07, 0x8b, 0xf9, 0xef, 0x50, 0x1f, 0x8d, 0xf8, 0x88, 0xcb, 0x63, 0x2b, 0x3a, 0xc5,
	0xd1, 0xc6, 0x77, 0x90, 0x31, 0xa7, 0xfc, 0xd4, 0x17, 0xe8, 0x11, 0x68, 0xe7, 0xaf, 0xf9, 0x84,
	0x1a, 0x4a, 0x5d, 0xd9, 0x4f, 0x39, 0xf1, 0x03, 0xaa, 0x02, 0x9c, 0x04, 0xd8, 0x13, 0x8c, 0xfb,
	0x78, 0x62, 0xa8, 0x12, 0xda, 0x88, 0x34, 0xfe, 0x4c, 0x83, 0xd6, 0x8b, 0x8a, 0x46, 0x5f, 0x42,
	0x6e, 0x4a, 0x05, 0x26, 0x58, 0x60, 0x99, 0x22, 0xff, 0xbc, 0xd4, 0x94, 0xa5, 0x34, 0x8f, 0x56,
	0x61, 0x27, 0x21, 0xa0, 0x8f, 0x40, 0x65, 0x44, 0xa6, 0x2b, 0xb4, 0x33, 0xcb, 0x45, 0x4d, 0xb5,
	0x2d, 0x47, 0x65, 0x04, 0x7d, 0x0b, 0x19, 0x11, 0x60, 0x42, 0x03, 0x23, 0x25, 0xb1, 0xbd, 0xb7,
	0x8b, 0x5a, 0xfd, 0xb6, 0x77, 0x6c, 0x9a, 0x84, 0x04, 0x34, 0x0c, 0x9d, 0x95, 0x06, 0x1d, 0xc2,
	0xae, 0x6c, 0xa0, 0x1b, 0x75, 0xd0, 0x65, 0xc4, 0x48, 0xcb, 0x24, 0xa5, 0xe5, 0xa2, 0x96, 0x97,
	0x45, 0xb6, 0x39, 0x1f, 0xdb, 0x96, 0x93, 0xe7, 0xc9, 0x03, 0x41, 0x9f, 0x41, 0x3a, 0x64, 0x84,
	0x1a, 0x5a, 0x5d, 0xd9, 0x2f, 0x3e, 0x2f, 0x35, 0x13, 0x0b, 0x9a, 0x7d, 0x46, 0xa8, 0x23, 0x41,
	0xf4, 0x0d, 0xc4, 0x1a, 0x37, 0x14, 0x58, 0x50, 0x23, 0x23, 0xb9, 0x8f, 0x37, 0xb8, 0x32, 0x7d,
	0x3f, 0x02, 0x1d, 0xe0, 0xc9, 0x19, 0x7d, 0x0d, 0x45, 0x1e, 0xb0, 0x11, 0xf3, 0xf1, 0xc4, 0xe5,
	0x27, 0x27, 0x34, 0x30, 0xb2, 0xb2, 0x35, 0xd0, 0x8c, 0xfc, 0x69, 0x76, 0x38, 0xf3, 0x9d, 0xdd,
	0x6b, 0x46, 0x2f, 0x22, 0xa0, 0x43, 0x28, 0x05, 0x74, 0x8a, 0x99, 0xcf, 0xfc, 0xd1, 0x4a, 0x93,
	0xbb, 0xa1, 0x29, 0x26, 0x94, 0x58, 0xf4, 0x05, 0x68, 0xb3, 0x80, 0x79, 0xd4, 0xd0, 0x25, 0xf5,
	0x83, 0x8d, 0xca, 0x62, 0x7b, 0x9d, 0x18, 0x47, 0x9f, 0x80, 0x2e, 0x9b, 0xe5, 0x32, 0x12, 0x1a,
	0x50, 0x4f, 0xed, 0x17, 0x9c, 0x9c, 0x0c, 0xd8, 0x24, 0x44, 0x16, 0x80, 0x17, 0x50, 0x2c, 0x28,
	0x71, 0xb1, 0x30, 0xf2, 0x91, 0xd9, 0xed, 0xcf, 0xdf, 0x2e, 0x6a, 0x9f, 0xde, 0xea, 0xc0, 0x8f,
	0x3e, 0xbb, 0x18, 0xb0, 0x29, 0x75, 0xf4, 0x95, 0xd0, 0x14, 0x51, 0x96, 0xd3, 0x19, 0xb9, 0xce,
	0x52, 0xd8, 0x2a, 0xcb, 0x4a, 0x68, 0x8a, 0xc6, 0xef, 0x29, 0xd0, 0x06, 0x51, 0x61, 0x0f, 0x33,
	0x58, 0x37, 0x46, 0x23, 0x75, 0x8f, 0xd1, 0x78, 0x0a, 0xb9, 0x58, 0x94, 0x8c, 0x52, 0x7e, 0xb9,
	0xa8, 0x65, 0x25, 0xdf, 0xb6, 0x9c, 0xac, 0x04, 0x6d, 0x82, 0x5e, 0x80, 0x26, 0xf0, 0x98, 0x06,
	0x72, 0x86, 0xee, 0x3b, 0xb4, 0xb1, 0x24, 0xd2, 0x4e, 0xa5, 0x36, 0xb3, 0x8d, 0x56, 0x4a, 0xd0,
	0x01, 0x80, 0x3c, 0xb8, 0x33, 0xcc, 0xc8, 0x7f, 0x4c, 0x96, 0x2e, 0xd1, 0x57, 0x98, 0x91, 0x88,
	0x2a, 0xd6, 0xd4, 0x9b, 0x03, 0xa5, 0x8b, 0x84, 0xfa, 0x3d, 0xe4, 0xe9, 0x05, 0xf5, 0x4e, 0x57,
	0x06, 0xea, 0xdb, 0x18, 0x08, 0xd7, 0x4a, 0x53, 0x34, 0x7e, 0x56, 0x41, 0x4f, 0x5a, 0xfb, 0x30,
	0x2e, 0x1e, 0x80, 0x3e, 0xc5, 0xc1, 0x98, 0x8a, 0xb5, 0x83, 0x85, 0xe5, 0xa2, 0x96, 0x3b, 0x92,
	0x41, 0xdb, 0x72, 0x72, 0x31, 0x6c, 0x13, 0xf4, 0x04, 0x00, 0x87, 0x63, 0x57, 0x30, 0x2f, 0x6a,
	0x6e, 0xe4, 0x9e, 0xee, 0xe8, 0x38, 0x1c, 0x0f, 0x64, 0x20, 0x82, 0x87, 0x8c, 0x5c, 0xc3, 0x5a,
	0x0c, 0x0f, 0x19, 0x59, 0xc1, 0x4f, 0xa1, 0x24, 0xb8, 0xc0, 0x13, 0x37, 0xca, 0xe1, 0x45, 0x17,
	0x48, 0xfa, 0x93, 0x72, 0x76, 0x65, 0xd8, 0x0c, 0xc7, 0x1d, 0xb9, 0x34, 0x13, 0x5e, 0x94, 0x2c,
	0xe6, 0x65, 0x37, 0x78, 0x6d, 0x46, 0x24, 0xaf, 0x31, 0x57, 0x20, 0x13, 0x17, 0xf9, 0x30, 0x8d,
	0x78, 0x01, 0x1a, 0x3f, 0xf7, 0xb7, 0x5c, 0x93, 0xb1, 0x04, 0x21, 0x48, 0xfb, 0x78, 0x4a, 0x57,
	0x3d, 0x91, 0xe7, 0xc6, 0x3f, 0x0a, 0x14, 0x3b, 0xf2, 0x06, 0x4b, 0xc7, 0x8e, 0xc2, 0xd1, 0x76,
	0x75, 0xae, 0xf7, 0xb6, 0xfa, 0x10, 0x7b, 0xfb, 0x3e, 0x97, 0xb3, 0x0e, 0x5a, 0xbc, 0x1d, 0xd3,
	0x37, 0x86, 0x39, 0x06, 0xd6, 0x4b, 0x51, 0xbb, 0x7b, 0x29, 0x36, 0x28, 0x14, 0x3b, 0xd8, 0xf7,
	0xe8, 0xe4, 0xff, 0xbd, 0xfc, 0xe6, 0x9a, 0x50, 0x6f, 0x5f, 0x13, 0x8d, 0xdf, 0x14, 0x40, 0x1b,
	0x4d, 0x8e, 0xde, 0x63, 0xeb, 0xdf, 0x7a, 0xe7, 0x06, 0xa8, 0x5b, 0xdc, 0x80, 0xd4, 0xdd, 0x37,
	0x20, 0xfd, 0xde, 0x0d, 0x78, 0xf6, 0xab, 0x02, 0xb0, 0xfe, 0xa8, 0xa1, 0x3d, 0xf8, 0xb0, 0xe7,
	0x58, 0x5d, 0xc7, 0xed, 0x0f, 0xcc, 0x41, 0xd7, 0xb5, 0x8f, 0x7f, 0x32, 0x5f, 0xda, 0x56, 0x79,
	0xa7, 0x92, 0xbf, 0x9c, 0xd7, 0xb3, 0xb6, 0x7f, 0x86, 0x27, 0x8c, 0xa0, 0x2a, 0x94, 0x37, 0x59,
	0xbd, 0x57, 0xdd, 0xe3, 0xb2, 0x52, 0xc9, 0x5d, 0xce, 0xeb, 0xe9, 0xde, 0x8c, 0xfa, 0xef, 0xe3,
	0x56, 0xef, 0xb8, 0x5b, 0x56, 0x63, 0xdc, 0xe2, 0x3e, 0x45, 0x0d, 0x40, 0x9b, 0x78, 0xc7, 0x3c,
	0xee, 0x74, 0x5f, 0x96, 0x53, 0x15, 0xb8, 0x9c, 0xd7, 0x33, 0xb1, 0x45, 0xcf, 0xfa, 0x90, 0x8e,
	0x3e, 0xcc, 0xe8, 0x09, 0x14, 0xfa, 0xb6, 0x75, 0x6b, 0x29, 0x8f, 0x21, 0x27, 0x61, 0xb3, 0xff,
	0x43, 0x59, 0xa9, 0x64, 0x2f, 0xe7, 0xf5, 0x94, 0x19, 0x8e, 0x93, 0x70, 0xdb, 0xb6, 0xca, 0x6a,
	0x1c, 0x6e, 0x33, 0xd2, 0x36, 0xfe, 0x58, 0x56, 0x95, 0x37, 0xcb, 0xaa, 0xf2, 0xf7, 0xb2, 0xaa,
	0xfc, 0x72, 0x55, 0xdd, 0x79, 0x73, 0x55, 0xdd, 0xf9, 0xeb, 0xaa, 0xba, 0x33, 0xcc, 0xc8, 0xff,
	0x49, 0x87, 0xff, 0x06, 0x00, 0x00, 0xff, 0xff, 0x77, 0xb3, 0x6c, 0x8b, 0xb4, 0x09, 0x00, 0x00,
}

func (m *Amount) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Amount) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Whole != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCodec(dAtA, i, uint64(m.Whole))
	}
	if m.Fractional != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCodec(dAtA, i, uint64(m.Fractional))
	}
	return i, nil
}

func (m *Order) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Order) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Metadata != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCodec(dAtA, i, uint64(m.Metadata.Size()))
		n1, err := m.Metadata.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if len(m.ID) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCodec(dAtA, i, uint64(len(m.ID)))
		i += copy(dAtA[i:], m.ID)
	}
	if len(m.Trader) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCodec(dAtA, i, uint64(len(m.Trader)))
		i += copy(dAtA[i:], m.Trader)
	}
	if len(m.OrderBookID) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCodec(dAtA, i, uint64(len(m.OrderBookID)))
		i += copy(dAtA[i:], m.OrderBookID)
	}
	if m.Side != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintCodec(dAtA, i, uint64(m.Side))
	}
	if m.OrderState != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintCodec(dAtA, i, uint64(m.OrderState))
	}
	if m.OriginalOffer != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintCodec(dAtA, i, uint64(m.OriginalOffer.Size()))
		n2, err := m.OriginalOffer.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.RemainingOffer != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintCodec(dAtA, i, uint64(m.RemainingOffer.Size()))
		n3, err := m.RemainingOffer.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.Price != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintCodec(dAtA, i, uint64(m.Price.Size()))
		n4, err := m.Price.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if len(m.TradeIds) > 0 {
		for _, b := range m.TradeIds {
			dAtA[i] = 0x52
			i++
			i = encodeVarintCodec(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if m.CreatedAt != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintCodec(dAtA, i, uint64(m.CreatedAt))
	}
	if m.UpdatedAt != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintCodec(dAtA, i, uint64(m.UpdatedAt))
	}
	return i, nil
}

func (m *Trade) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Trade) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Metadata != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCodec(dAtA, i, uint64(m.Metadata.Size()))
		n5, err := m.Metadata.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if len(m.ID) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCodec(dAtA, i, uint64(len(m.ID)))
		i += copy(dAtA[i:], m.ID)
	}
	if len(m.OrderBookID) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCodec(dAtA, i, uint64(len(m.OrderBookID)))
		i += copy(dAtA[i:], m.OrderBookID)
	}
	if len(m.OrderID) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCodec(dAtA, i, uint64(len(m.OrderID)))
		i += copy(dAtA[i:], m.OrderID)
	}
	if len(m.Taker) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintCodec(dAtA, i, uint64(len(m.Taker)))
		i += copy(dAtA[i:], m.Taker)
	}
	if len(m.Maker) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintCodec(dAtA, i, uint64(len(m.Maker)))
		i += copy(dAtA[i:], m.Maker)
	}
	if m.MakerPaid != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintCodec(dAtA, i, uint64(m.MakerPaid.Size()))
		n6, err := m.MakerPaid.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.TakerPaid != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintCodec(dAtA, i, uint64(m.TakerPaid.Size()))
		n7, err := m.TakerPaid.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.ExecutedAt != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintCodec(dAtA, i, uint64(m.ExecutedAt))
	}
	return i, nil
}

func (m *OrderBook) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OrderBook) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Metadata != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCodec(dAtA, i, uint64(m.Metadata.Size()))
		n8, err := m.Metadata.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if len(m.ID) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCodec(dAtA, i, uint64(len(m.ID)))
		i += copy(dAtA[i:], m.ID)
	}
	if len(m.MarketID) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCodec(dAtA, i, uint64(len(m.MarketID)))
		i += copy(dAtA[i:], m.MarketID)
	}
	if len(m.AskTicker) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCodec(dAtA, i, uint64(len(m.AskTicker)))
		i += copy(dAtA[i:], m.AskTicker)
	}
	if len(m.BidTicker) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintCodec(dAtA, i, uint64(len(m.BidTicker)))
		i += copy(dAtA[i:], m.BidTicker)
	}
	if m.TotalAskCount != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintCodec(dAtA, i, uint64(m.TotalAskCount))
	}
	if m.TotalBidCount != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintCodec(dAtA, i, uint64(m.TotalBidCount))
	}
	return i, nil
}

func (m *Market) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Market) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Metadata != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCodec(dAtA, i, uint64(m.Metadata.Size()))
		n9, err := m.Metadata.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if len(m.ID) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCodec(dAtA, i, uint64(len(m.ID)))
		i += copy(dAtA[i:], m.ID)
	}
	if len(m.Owner) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCodec(dAtA, i, uint64(len(m.Owner)))
		i += copy(dAtA[i:], m.Owner)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCodec(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	return i, nil
}

func (m *CreateOrderMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateOrderMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Metadata != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCodec(dAtA, i, uint64(m.Metadata.Size()))
		n10, err := m.Metadata.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if len(m.Trader) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCodec(dAtA, i, uint64(len(m.Trader)))
		i += copy(dAtA[i:], m.Trader)
	}
	if len(m.OrderBookID) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCodec(dAtA, i, uint64(len(m.OrderBookID)))
		i += copy(dAtA[i:], m.OrderBookID)
	}
	if m.Offer != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCodec(dAtA, i, uint64(m.Offer.Size()))
		n11, err := m.Offer.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.Price != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintCodec(dAtA, i, uint64(m.Price.Size()))
		n12, err := m.Price.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	return i, nil
}

func (m *CancelOrderMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CancelOrderMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Metadata != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCodec(dAtA, i, uint64(m.Metadata.Size()))
		n13, err := m.Metadata.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if len(m.OrderID) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCodec(dAtA, i, uint64(len(m.OrderID)))
		i += copy(dAtA[i:], m.OrderID)
	}
	return i, nil
}

func (m *CreateOrderBookMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateOrderBookMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Metadata != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCodec(dAtA, i, uint64(m.Metadata.Size()))
		n14, err := m.Metadata.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if len(m.MarketID) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCodec(dAtA, i, uint64(len(m.MarketID)))
		i += copy(dAtA[i:], m.MarketID)
	}
	if len(m.AskTicker) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCodec(dAtA, i, uint64(len(m.AskTicker)))
		i += copy(dAtA[i:], m.AskTicker)
	}
	if len(m.BidTicker) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCodec(dAtA, i, uint64(len(m.BidTicker)))
		i += copy(dAtA[i:], m.BidTicker)
	}
	return i, nil
}

func encodeVarintCodec(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Amount) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Whole != 0 {
		n += 1 + sovCodec(uint64(m.Whole))
	}
	if m.Fractional != 0 {
		n += 1 + sovCodec(uint64(m.Fractional))
	}
	return n
}

func (m *Order) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovCodec(uint64(l))
	}
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovCodec(uint64(l))
	}
	l = len(m.Trader)
	if l > 0 {
		n += 1 + l + sovCodec(uint64(l))
	}
	l = len(m.OrderBookID)
	if l > 0 {
		n += 1 + l + sovCodec(uint64(l))
	}
	if m.Side != 0 {
		n += 1 + sovCodec(uint64(m.Side))
	}
	if m.OrderState != 0 {
		n += 1 + sovCodec(uint64(m.OrderState))
	}
	if m.OriginalOffer != nil {
		l = m.OriginalOffer.Size()
		n += 1 + l + sovCodec(uint64(l))
	}
	if m.RemainingOffer != nil {
		l = m.RemainingOffer.Size()
		n += 1 + l + sovCodec(uint64(l))
	}
	if m.Price != nil {
		l = m.Price.Size()
		n += 1 + l + sovCodec(uint64(l))
	}
	if len(m.TradeIds) > 0 {
		for _, b := range m.TradeIds {
			l = len(b)
			n += 1 + l + sovCodec(uint64(l))
		}
	}
	if m.CreatedAt != 0 {
		n += 1 + sovCodec(uint64(m.CreatedAt))
	}
	if m.UpdatedAt != 0 {
		n += 1 + sovCodec(uint64(m.UpdatedAt))
	}
	return n
}

func (m *Trade) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovCodec(uint64(l))
	}
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovCodec(uint64(l))
	}
	l = len(m.OrderBookID)
	if l > 0 {
		n += 1 + l + sovCodec(uint64(l))
	}
	l = len(m.OrderID)
	if l > 0 {
		n += 1 + l + sovCodec(uint64(l))
	}
	l = len(m.Taker)
	if l > 0 {
		n += 1 + l + sovCodec(uint64(l))
	}
	l = len(m.Maker)
	if l > 0 {
		n += 1 + l + sovCodec(uint64(l))
	}
	if m.MakerPaid != nil {
		l = m.MakerPaid.Size()
		n += 1 + l + sovCodec(uint64(l))
	}
	if m.TakerPaid != nil {
		l = m.TakerPaid.Size()
		n += 1 + l + sovCodec(uint64(l))
	}
	if m.ExecutedAt != 0 {
		n += 1 + sovCodec(uint64(m.ExecutedAt))
	}
	return n
}

func (m *OrderBook) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovCodec(uint64(l))
	}
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovCodec(uint64(l))
	}
	l = len(m.MarketID)
	if l > 0 {
		n += 1 + l + sovCodec(uint64(l))
	}
	l = len(m.AskTicker)
	if l > 0 {
		n += 1 + l + sovCodec(uint64(l))
	}
	l = len(m.BidTicker)
	if l > 0 {
		n += 1 + l + sovCodec(uint64(l))
	}
	if m.TotalAskCount != 0 {
		n += 1 + sovCodec(uint64(m.TotalAskCount))
	}
	if m.TotalBidCount != 0 {
		n += 1 + sovCodec(uint64(m.TotalBidCount))
	}
	return n
}

func (m *Market) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovCodec(uint64(l))
	}
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovCodec(uint64(l))
	}
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovCodec(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCodec(uint64(l))
	}
	return n
}

func (m *CreateOrderMsg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovCodec(uint64(l))
	}
	l = len(m.Trader)
	if l > 0 {
		n += 1 + l + sovCodec(uint64(l))
	}
	l = len(m.OrderBookID)
	if l > 0 {
		n += 1 + l + sovCodec(uint64(l))
	}
	if m.Offer != nil {
		l = m.Offer.Size()
		n += 1 + l + sovCodec(uint64(l))
	}
	if m.Price != nil {
		l = m.Price.Size()
		n += 1 + l + sovCodec(uint64(l))
	}
	return n
}

func (m *CancelOrderMsg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovCodec(uint64(l))
	}
	l = len(m.OrderID)
	if l > 0 {
		n += 1 + l + sovCodec(uint64(l))
	}
	return n
}

func (m *CreateOrderBookMsg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovCodec(uint64(l))
	}
	l = len(m.MarketID)
	if l > 0 {
		n += 1 + l + sovCodec(uint64(l))
	}
	l = len(m.AskTicker)
	if l > 0 {
		n += 1 + l + sovCodec(uint64(l))
	}
	l = len(m.BidTicker)
	if l > 0 {
		n += 1 + l + sovCodec(uint64(l))
	}
	return n
}

func sovCodec(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozCodec(x uint64) (n int) {
	return sovCodec(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Amount) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCodec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Amount: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Amount: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Whole", wireType)
			}
			m.Whole = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Whole |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fractional", wireType)
			}
			m.Fractional = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Fractional |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCodec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCodec
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCodec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Order) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCodec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Order: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Order: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &weave.Metadata{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = append(m.ID[:0], dAtA[iNdEx:postIndex]...)
			if m.ID == nil {
				m.ID = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Trader", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Trader = append(m.Trader[:0], dAtA[iNdEx:postIndex]...)
			if m.Trader == nil {
				m.Trader = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderBookID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderBookID = append(m.OrderBookID[:0], dAtA[iNdEx:postIndex]...)
			if m.OrderBookID == nil {
				m.OrderBookID = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Side", wireType)
			}
			m.Side = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Side |= Side(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderState", wireType)
			}
			m.OrderState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OrderState |= OrderState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginalOffer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OriginalOffer == nil {
				m.OriginalOffer = &coin.Coin{}
			}
			if err := m.OriginalOffer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemainingOffer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RemainingOffer == nil {
				m.RemainingOffer = &coin.Coin{}
			}
			if err := m.RemainingOffer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Price == nil {
				m.Price = &Amount{}
			}
			if err := m.Price.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TradeIds", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TradeIds = append(m.TradeIds, make([]byte, postIndex-iNdEx))
			copy(m.TradeIds[len(m.TradeIds)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			m.CreatedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreatedAt |= github_com_iov_one_weave.UnixTime(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			m.UpdatedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdatedAt |= github_com_iov_one_weave.UnixTime(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCodec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCodec
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCodec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Trade) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCodec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Trade: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Trade: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &weave.Metadata{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = append(m.ID[:0], dAtA[iNdEx:postIndex]...)
			if m.ID == nil {
				m.ID = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderBookID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderBookID = append(m.OrderBookID[:0], dAtA[iNdEx:postIndex]...)
			if m.OrderBookID == nil {
				m.OrderBookID = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderID = append(m.OrderID[:0], dAtA[iNdEx:postIndex]...)
			if m.OrderID == nil {
				m.OrderID = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Taker", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Taker = append(m.Taker[:0], dAtA[iNdEx:postIndex]...)
			if m.Taker == nil {
				m.Taker = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Maker", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Maker = append(m.Maker[:0], dAtA[iNdEx:postIndex]...)
			if m.Maker == nil {
				m.Maker = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MakerPaid", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MakerPaid == nil {
				m.MakerPaid = &coin.Coin{}
			}
			if err := m.MakerPaid.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TakerPaid", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TakerPaid == nil {
				m.TakerPaid = &coin.Coin{}
			}
			if err := m.TakerPaid.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecutedAt", wireType)
			}
			m.ExecutedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExecutedAt |= github_com_iov_one_weave.UnixTime(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCodec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCodec
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCodec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OrderBook) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCodec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OrderBook: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OrderBook: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &weave.Metadata{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = append(m.ID[:0], dAtA[iNdEx:postIndex]...)
			if m.ID == nil {
				m.ID = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MarketID = append(m.MarketID[:0], dAtA[iNdEx:postIndex]...)
			if m.MarketID == nil {
				m.MarketID = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AskTicker", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AskTicker = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BidTicker", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BidTicker = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalAskCount", wireType)
			}
			m.TotalAskCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalAskCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalBidCount", wireType)
			}
			m.TotalBidCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalBidCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCodec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCodec
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCodec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Market) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCodec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Market: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Market: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &weave.Metadata{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = append(m.ID[:0], dAtA[iNdEx:postIndex]...)
			if m.ID == nil {
				m.ID = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = append(m.Owner[:0], dAtA[iNdEx:postIndex]...)
			if m.Owner == nil {
				m.Owner = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCodec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCodec
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCodec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateOrderMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCodec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateOrderMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateOrderMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &weave.Metadata{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Trader", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Trader = append(m.Trader[:0], dAtA[iNdEx:postIndex]...)
			if m.Trader == nil {
				m.Trader = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderBookID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderBookID = append(m.OrderBookID[:0], dAtA[iNdEx:postIndex]...)
			if m.OrderBookID == nil {
				m.OrderBookID = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Offer == nil {
				m.Offer = &coin.Coin{}
			}
			if err := m.Offer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Price == nil {
				m.Price = &Amount{}
			}
			if err := m.Price.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCodec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCodec
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCodec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CancelOrderMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCodec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CancelOrderMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CancelOrderMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &weave.Metadata{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderID = append(m.OrderID[:0], dAtA[iNdEx:postIndex]...)
			if m.OrderID == nil {
				m.OrderID = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCodec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCodec
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCodec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateOrderBookMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCodec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateOrderBookMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateOrderBookMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &weave.Metadata{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MarketID = append(m.MarketID[:0], dAtA[iNdEx:postIndex]...)
			if m.MarketID == nil {
				m.MarketID = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AskTicker", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AskTicker = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BidTicker", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BidTicker = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCodec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCodec
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCodec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCodec(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCodec
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthCodec
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthCodec
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowCodec
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipCodec(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthCodec
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthCodec = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCodec   = fmt.Errorf("proto: integer overflow")
)
